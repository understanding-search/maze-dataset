{
  "name": "basic",
  "grid_n": 20,
  "maze_ctor": "gen_kruskal",
  "maze_ctor_kwargs": {},
  "description": "Basic KRUSKAL maze (20x20)",
  "tags": [
    "algo:kruskal",
    "basic",
    "grid:20"
  ],
  "config": {
    "__muutils_format__": "MazeDatasetConfig(SerializableDataclass)",
    "name": "basic",
    "seq_len_min": 1,
    "seq_len_max": 512,
    "seed": 42,
    "applied_filters": [],
    "grid_n": 20,
    "n_mazes": 10,
    "maze_ctor": {
      "__name__": "gen_kruskal",
      "__module__": "maze_dataset.generation.generators",
      "__doc__": [
        "Generate a maze using Kruskal's algorithm.",
        "This function generates a random spanning tree over a grid using Kruskal's algorithm.",
        "Each cell is treated as a node, and all valid adjacent edges are listed and processed",
        "in random order. An edge is added (i.e. its passage carved) only if it connects two cells",
        "that are not already connected. The resulting maze is a perfect maze (i.e. a spanning tree)",
        "without cycles.",
        "https://en.wikipedia.org/wiki/Kruskal's_algorithm",
        "# Parameters:",
        "- `grid_shape : Coord | CoordTup`",
        "The shape of the maze grid (for example, `(n_rows, n_cols)`).",
        "- `lattice_dim : int`",
        "The lattice dimension (default is `2`).",
        "- `start_coord : Coord | None`",
        "Optionally, specify a starting coordinate. If `None`, a random coordinate will be chosen.",
        "- `**kwargs`",
        "Additional keyword arguments (currently unused).",
        "# Returns:",
        "- `LatticeMaze`",
        "A maze represented by a connection list, generated as a spanning tree using Kruskal's algorithm.",
        "# Usage:",
        "```python",
        "maze = gen_kruskal((10, 10))",
        "```"
      ],
      "source_code": [
        "\t@staticmethod",
        "\tdef gen_kruskal(",
        "\t\tgrid_shape: \"Coord | CoordTup\",",
        "\t\tlattice_dim: int = 2,",
        "\t\tstart_coord: \"Coord | None\" = None,",
        "\t) -> \"LatticeMaze\":",
        "\t\t\"\"\"Generate a maze using Kruskal's algorithm.",
        "",
        "\t\tThis function generates a random spanning tree over a grid using Kruskal's algorithm.",
        "\t\tEach cell is treated as a node, and all valid adjacent edges are listed and processed",
        "\t\tin random order. An edge is added (i.e. its passage carved) only if it connects two cells",
        "\t\tthat are not already connected. The resulting maze is a perfect maze (i.e. a spanning tree)",
        "\t\twithout cycles.",
        "",
        "\t\thttps://en.wikipedia.org/wiki/Kruskal's_algorithm",
        "",
        "\t\t# Parameters:",
        "\t\t- `grid_shape : Coord | CoordTup`",
        "\t\t\tThe shape of the maze grid (for example, `(n_rows, n_cols)`).",
        "\t\t- `lattice_dim : int`",
        "\t\t\tThe lattice dimension (default is `2`).",
        "\t\t- `start_coord : Coord | None`",
        "\t\t\tOptionally, specify a starting coordinate. If `None`, a random coordinate will be chosen.",
        "\t\t- `**kwargs`",
        "\t\t\tAdditional keyword arguments (currently unused).",
        "",
        "\t\t# Returns:",
        "\t\t- `LatticeMaze`",
        "\t\t\tA maze represented by a connection list, generated as a spanning tree using Kruskal's algorithm.",
        "",
        "\t\t# Usage:",
        "\t\t```python",
        "\t\tmaze = gen_kruskal((10, 10))",
        "\t\t```",
        "\t\t\"\"\"",
        "\t\tassert lattice_dim == 2, (  # noqa: PLR2004",
        "\t\t\t\"Kruskal's algorithm is only implemented for 2D lattices.\"",
        "\t\t)",
        "\t\t# Convert grid_shape to a tuple of ints",
        "\t\tgrid_shape = tuple(int(x) for x in grid_shape)",
        "\t\tn_rows, n_cols = grid_shape",
        "",
        "\t\t# Initialize union-find data structure.",
        "\t\tparent: dict[tuple[int, int], tuple[int, int]] = {}",
        "",
        "\t\tdef find(cell: tuple[int, int]) -> tuple[int, int]:",
        "\t\t\twhile parent[cell] != cell:",
        "\t\t\t\tparent[cell] = parent[parent[cell]]",
        "\t\t\t\tcell = parent[cell]",
        "\t\t\treturn cell",
        "",
        "\t\tdef union(cell1: tuple[int, int], cell2: tuple[int, int]) -> None:",
        "\t\t\troot1 = find(cell1)",
        "\t\t\troot2 = find(cell2)",
        "\t\t\tparent[root2] = root1",
        "",
        "\t\t# Initialize each cell as its own set.",
        "\t\tfor i in range(n_rows):",
        "\t\t\tfor j in range(n_cols):",
        "\t\t\t\tparent[(i, j)] = (i, j)",
        "",
        "\t\t# List all possible edges.",
        "\t\t# For vertical edges (i.e. connecting a cell to its right neighbor):",
        "\t\tedges: list[tuple[tuple[int, int], tuple[int, int], int]] = []",
        "\t\tfor i in range(n_rows):",
        "\t\t\tfor j in range(n_cols - 1):",
        "\t\t\t\tedges.append(((i, j), (i, j + 1), 1))",
        "\t\t# For horizontal edges (i.e. connecting a cell to its bottom neighbor):",
        "\t\tfor i in range(n_rows - 1):",
        "\t\t\tfor j in range(n_cols):",
        "\t\t\t\tedges.append(((i, j), (i + 1, j), 0))",
        "",
        "\t\t# Shuffle the list of edges.",
        "\t\timport random",
        "",
        "\t\trandom.shuffle(edges)",
        "",
        "\t\t# Initialize connection_list with no connections.",
        "\t\t# connection_list[0] stores downward connections (from cell (i,j) to (i+1,j)).",
        "\t\t# connection_list[1] stores rightward connections (from cell (i,j) to (i,j+1)).",
        "\t\timport numpy as np",
        "",
        "\t\tconnection_list = np.zeros((2, n_rows, n_cols), dtype=bool)",
        "",
        "\t\t# Process each edge; if it connects two different trees, union them and carve the passage.",
        "\t\tfor cell1, cell2, direction in edges:",
        "\t\t\tif find(cell1) != find(cell2):",
        "\t\t\t\tunion(cell1, cell2)",
        "\t\t\t\tif direction == 0:",
        "\t\t\t\t\t# Horizontal edge: connection is stored in connection_list[0] at cell1.",
        "\t\t\t\t\tconnection_list[0, cell1[0], cell1[1]] = True",
        "\t\t\t\telse:",
        "\t\t\t\t\t# Vertical edge: connection is stored in connection_list[1] at cell1.",
        "\t\t\t\t\tconnection_list[1, cell1[0], cell1[1]] = True",
        "",
        "\t\tif start_coord is None:",
        "\t\t\tstart_coord = tuple(np.random.randint(0, n) for n in grid_shape)",
        "",
        "\t\tgeneration_meta: dict = dict(",
        "\t\t\tfunc_name=\"gen_kruskal\",",
        "\t\t\tgrid_shape=grid_shape,",
        "\t\t\tstart_coord=start_coord,",
        "\t\t\talgorithm=\"kruskal\",",
        "\t\t\tfully_connected=True,",
        "\t\t)",
        "\t\treturn LatticeMaze(",
        "\t\t\tconnection_list=connection_list, generation_meta=generation_meta",
        "\t\t)"
      ]
    },
    "maze_ctor_kwargs": {},
    "endpoint_kwargs": {
      "except_on_no_valid_endpoint": false
    },
    "_fname_loaded": null,
    "fname": "basic-g20-n10-a_kruskal-h51224",
    "versions": {
      "config": "1.0",
      "maze_dataset": "1.3.0"
    }
  },
  "fname": "basic-g20-n10-a_kruskal-h51224"
}