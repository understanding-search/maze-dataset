{
  "name": "basic",
  "grid_n": 20,
  "maze_ctor": "gen_wilson",
  "maze_ctor_kwargs": {},
  "description": "Basic WILSON maze (20x20)",
  "tags": [
    "algo:wilson",
    "basic",
    "grid:20"
  ],
  "config": {
    "__muutils_format__": "MazeDatasetConfig(SerializableDataclass)",
    "name": "basic",
    "seq_len_min": 1,
    "seq_len_max": 512,
    "seed": 42,
    "applied_filters": [],
    "grid_n": 20,
    "n_mazes": 10,
    "maze_ctor": {
      "__name__": "gen_wilson",
      "__module__": "maze_dataset.generation.generators",
      "__doc__": [
        "Generate a lattice maze using Wilson's algorithm.",
        "# Algorithm",
        "Wilson's algorithm generates an unbiased (random) maze",
        "sampled from the uniform distribution over all mazes, using loop-erased random walks. The generated maze is",
        "acyclic and all cells are part of a unique connected space.",
        "https://en.wikipedia.org/wiki/Maze_generation_algorithm#Wilson's_algorithm"
      ],
      "source_code": [
        "\t@staticmethod",
        "\tdef gen_wilson(",
        "\t\tgrid_shape: Coord | CoordTup,",
        "\t\t**kwargs,",
        "\t) -> LatticeMaze:",
        "\t\t\"\"\"Generate a lattice maze using Wilson's algorithm.",
        "",
        "\t\t# Algorithm",
        "\t\tWilson's algorithm generates an unbiased (random) maze",
        "\t\tsampled from the uniform distribution over all mazes, using loop-erased random walks. The generated maze is",
        "\t\tacyclic and all cells are part of a unique connected space.",
        "\t\thttps://en.wikipedia.org/wiki/Maze_generation_algorithm#Wilson's_algorithm",
        "\t\t\"\"\"",
        "\t\tassert not kwargs, (",
        "\t\t\tf\"gen_wilson does not take any additional arguments, got {kwargs = }\"",
        "\t\t)",
        "",
        "\t\tgrid_shape_: Coord = np.array(grid_shape)",
        "",
        "\t\t# Initialize grid and visited cells",
        "\t\tconnection_list: ConnectionList = np.zeros((2, *grid_shape_), dtype=np.bool_)",
        "\t\tvisited: Bool[np.ndarray, \"x y\"] = np.zeros(grid_shape_, dtype=np.bool_)",
        "",
        "\t\t# Choose a random cell and mark it as visited",
        "\t\tstart_coord: Coord = _random_start_coord(grid_shape_, None)",
        "\t\tvisited[start_coord[0], start_coord[1]] = True",
        "\t\tdel start_coord",
        "",
        "\t\twhile not visited.all():",
        "\t\t\t# Perform loop-erased random walk from another random cell",
        "",
        "\t\t\t# Choose walk_start only from unvisited cells",
        "\t\t\tunvisited_coords: CoordArray = np.column_stack(np.where(~visited))",
        "\t\t\twalk_start: Coord = unvisited_coords[",
        "\t\t\t\tnp.random.choice(unvisited_coords.shape[0])",
        "\t\t\t]",
        "",
        "\t\t\t# Perform the random walk",
        "\t\t\tpath: list[Coord] = [walk_start]",
        "\t\t\tcurrent: Coord = walk_start",
        "",
        "\t\t\t# exit the loop once the current path hits a visited cell",
        "\t\t\twhile not visited[current[0], current[1]]:",
        "\t\t\t\t# find a valid neighbor (one always exists on a lattice)",
        "\t\t\t\tneighbors: CoordArray = get_neighbors_in_bounds(current, grid_shape_)",
        "\t\t\t\tnext_cell: Coord = neighbors[np.random.choice(neighbors.shape[0])]",
        "",
        "\t\t\t\t# Check for loop",
        "\t\t\t\tloop_exit: int | None = None",
        "\t\t\t\tfor i, p in enumerate(path):",
        "\t\t\t\t\tif np.array_equal(next_cell, p):",
        "\t\t\t\t\t\tloop_exit = i",
        "\t\t\t\t\t\tbreak",
        "",
        "\t\t\t\t# erase the loop, or continue the walk",
        "\t\t\t\tif loop_exit is not None:",
        "\t\t\t\t\t# this removes everything after and including the loop start",
        "\t\t\t\t\tpath = path[: loop_exit + 1]",
        "\t\t\t\t\t# reset current cell to end of path",
        "\t\t\t\t\tcurrent = path[-1]",
        "\t\t\t\telse:",
        "\t\t\t\t\tpath.append(next_cell)",
        "\t\t\t\t\tcurrent = next_cell",
        "",
        "\t\t\t# Add the path to the maze",
        "\t\t\tfor i in range(len(path) - 1):",
        "\t\t\t\tc_1: Coord = path[i]",
        "\t\t\t\tc_2: Coord = path[i + 1]",
        "",
        "\t\t\t\t# find the dimension of the connection",
        "\t\t\t\tdelta: Coord = c_2 - c_1",
        "\t\t\t\tdim: int = int(np.argmax(np.abs(delta)))",
        "",
        "\t\t\t\t# if positive, down/right from current coord",
        "\t\t\t\t# if negative, up/left from current coord (down/right from neighbor)",
        "\t\t\t\tclist_node: Coord = c_1 if (delta.sum() > 0) else c_2",
        "\t\t\t\tconnection_list[dim, clist_node[0], clist_node[1]] = True",
        "\t\t\t\tvisited[c_1[0], c_1[1]] = True",
        "\t\t\t\t# we dont add c_2 because the last c_2 will have already been visited",
        "",
        "\t\treturn LatticeMaze(",
        "\t\t\tconnection_list=connection_list,",
        "\t\t\tgeneration_meta=dict(",
        "\t\t\t\tfunc_name=\"gen_wilson\",",
        "\t\t\t\tgrid_shape=grid_shape_,",
        "\t\t\t\tfully_connected=True,",
        "\t\t\t),",
        "\t\t)"
      ]
    },
    "maze_ctor_kwargs": {},
    "endpoint_kwargs": {
      "except_on_no_valid_endpoint": false
    },
    "_fname_loaded": null,
    "fname": "basic-g20-n10-a_wilson-h82017",
    "versions": {
      "config": "1.0",
      "maze_dataset": "1.3.2"
    }
  },
  "fname": "basic-g20-n10-a_wilson-h82017"
}