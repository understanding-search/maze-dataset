{
  "grid_n": 10,
  "maze_ctor": "gen_dfs",
  "name": "start_corner",
  "maze_ctor_kwargs": {
    "start_coord": [
      0,
      0
    ]
  },
  "description": "DFS starting from corner of grid",
  "tags": [
    "algo:dfs",
    "dfs",
    "constrained_dfs",
    "grid:10",
    "custom_start"
  ],
  "config": {
    "__muutils_format__": "MazeDatasetConfig(SerializableDataclass)",
    "name": "start_corner",
    "seq_len_min": 1,
    "seq_len_max": 512,
    "seed": 42,
    "applied_filters": [],
    "grid_n": 10,
    "n_mazes": 10,
    "maze_ctor": {
      "__name__": "gen_dfs",
      "__module__": "maze_dataset.generation.generators",
      "__doc__": [
        "generate a lattice maze using depth first search, iterative",
        "# Arguments",
        "- `grid_shape: Coord`: the shape of the grid",
        "- `lattice_dim: int`: the dimension of the lattice",
        "(default: `2`)",
        "- `accessible_cells: int | float |None`: the number of accessible cells in the maze. If `None`, defaults to the total number of cells in the grid. if a float, asserts it is <= 1 and treats it as a proportion of **total cells**",
        "(default: `None`)",
        "- `max_tree_depth: int | float | None`: the maximum depth of the tree. If `None`, defaults to `2 * accessible_cells`. if a float, asserts it is <= 1 and treats it as a proportion of the **sum of the grid shape**",
        "(default: `None`)",
        "- `do_forks: bool`: whether to allow forks in the maze. If `False`, the maze will be have no forks and will be a simple hallway.",
        "- `start_coord: Coord | None`: the starting coordinate of the generation algorithm. If `None`, defaults to a random coordinate.",
        "# algorithm",
        "1. Choose the initial cell, mark it as visited and push it to the stack",
        "2. While the stack is not empty",
        "1. Pop a cell from the stack and make it a current cell",
        "2. If the current cell has any neighbours which have not been visited",
        "1. Push the current cell to the stack",
        "2. Choose one of the unvisited neighbours",
        "3. Remove the wall between the current cell and the chosen cell",
        "4. Mark the chosen cell as visited and push it to the stack"
      ],
      "source_code": [
        "\t@staticmethod",
        "\tdef gen_dfs(",
        "\t\tgrid_shape: Coord | CoordTup,",
        "\t\t*,",
        "\t\tlattice_dim: int = 2,",
        "\t\taccessible_cells: float | None = None,",
        "\t\tmax_tree_depth: float | None = None,",
        "\t\tdo_forks: bool = True,",
        "\t\trandomized_stack: bool = False,",
        "\t\tstart_coord: Coord | None = None,",
        "\t) -> LatticeMaze:",
        "\t\t\"\"\"generate a lattice maze using depth first search, iterative",
        "",
        "\t\t# Arguments",
        "\t\t- `grid_shape: Coord`: the shape of the grid",
        "\t\t- `lattice_dim: int`: the dimension of the lattice",
        "\t\t\t(default: `2`)",
        "\t\t- `accessible_cells: int | float |None`: the number of accessible cells in the maze. If `None`, defaults to the total number of cells in the grid. if a float, asserts it is <= 1 and treats it as a proportion of **total cells**",
        "\t\t\t(default: `None`)",
        "\t\t- `max_tree_depth: int | float | None`: the maximum depth of the tree. If `None`, defaults to `2 * accessible_cells`. if a float, asserts it is <= 1 and treats it as a proportion of the **sum of the grid shape**",
        "\t\t\t(default: `None`)",
        "\t\t- `do_forks: bool`: whether to allow forks in the maze. If `False`, the maze will be have no forks and will be a simple hallway.",
        "\t\t- `start_coord: Coord | None`: the starting coordinate of the generation algorithm. If `None`, defaults to a random coordinate.",
        "",
        "\t\t# algorithm",
        "\t\t1. Choose the initial cell, mark it as visited and push it to the stack",
        "\t\t2. While the stack is not empty",
        "\t\t\t1. Pop a cell from the stack and make it a current cell",
        "\t\t\t2. If the current cell has any neighbours which have not been visited",
        "\t\t\t\t1. Push the current cell to the stack",
        "\t\t\t\t2. Choose one of the unvisited neighbours",
        "\t\t\t\t3. Remove the wall between the current cell and the chosen cell",
        "\t\t\t\t4. Mark the chosen cell as visited and push it to the stack",
        "\t\t\"\"\"",
        "\t\t# Default values if no constraints have been passed",
        "\t\tgrid_shape_: Coord = np.array(grid_shape)",
        "\t\tn_total_cells: int = int(np.prod(grid_shape_))",
        "",
        "\t\tn_accessible_cells: int",
        "\t\tif accessible_cells is None:",
        "\t\t\tn_accessible_cells = n_total_cells",
        "\t\telif isinstance(accessible_cells, float):",
        "\t\t\tassert accessible_cells <= 1, (",
        "\t\t\t\tf\"accessible_cells must be an int (count) or a float in the range [0, 1] (proportion), got {accessible_cells}\"",
        "\t\t\t)",
        "",
        "\t\t\tn_accessible_cells = int(accessible_cells * n_total_cells)",
        "\t\telse:",
        "\t\t\tassert isinstance(accessible_cells, int)",
        "\t\t\tn_accessible_cells = accessible_cells",
        "",
        "\t\tif max_tree_depth is None:",
        "\t\t\tmax_tree_depth = (",
        "\t\t\t\t2 * n_total_cells",
        "\t\t\t)  # We define max tree depth counting from the start coord in two directions. Therefore we divide by two in the if clause for neighboring sites later and multiply by two here.",
        "\t\telif isinstance(max_tree_depth, float):",
        "\t\t\tassert max_tree_depth <= 1, (",
        "\t\t\t\tf\"max_tree_depth must be an int (count) or a float in the range [0, 1] (proportion), got {max_tree_depth}\"",
        "\t\t\t)",
        "",
        "\t\t\tmax_tree_depth = int(max_tree_depth * np.sum(grid_shape_))",
        "",
        "\t\t# choose a random start coord",
        "\t\tstart_coord = _random_start_coord(grid_shape_, start_coord)",
        "",
        "\t\t# initialize the maze with no connections",
        "\t\tconnection_list: ConnectionList = np.zeros(",
        "\t\t\t(lattice_dim, grid_shape_[0], grid_shape_[1]),",
        "\t\t\tdtype=np.bool_,",
        "\t\t)",
        "",
        "\t\t# initialize the stack with the target coord",
        "\t\tvisited_cells: set[tuple[int, int]] = set()",
        "\t\tvisited_cells.add(tuple(start_coord))  # this wasnt a bug after all lol",
        "\t\tstack: list[Coord] = [start_coord]",
        "",
        "\t\t# initialize tree_depth_counter",
        "\t\tcurrent_tree_depth: int = 1",
        "",
        "\t\t# loop until the stack is empty or n_connected_cells is reached",
        "\t\twhile stack and (len(visited_cells) < n_accessible_cells):",
        "\t\t\t# get the current coord from the stack",
        "\t\t\tcurrent_coord: Coord",
        "\t\t\tif randomized_stack:",
        "\t\t\t\tcurrent_coord = stack.pop(random.randint(0, len(stack) - 1))",
        "\t\t\telse:",
        "\t\t\t\tcurrent_coord = stack.pop()",
        "",
        "\t\t\t# filter neighbors by being within grid bounds and being unvisited",
        "\t\t\tunvisited_neighbors_deltas: list[tuple[Coord, Coord]] = [",
        "\t\t\t\t(neighbor, delta)",
        "\t\t\t\tfor neighbor, delta in zip(",
        "\t\t\t\t\tcurrent_coord + NEIGHBORS_MASK,",
        "\t\t\t\t\tNEIGHBORS_MASK,",
        "\t\t\t\t\tstrict=False,",
        "\t\t\t\t)",
        "\t\t\t\tif (",
        "\t\t\t\t\t(tuple(neighbor) not in visited_cells)",
        "\t\t\t\t\tand (0 <= neighbor[0] < grid_shape_[0])",
        "\t\t\t\t\tand (0 <= neighbor[1] < grid_shape_[1])",
        "\t\t\t\t)",
        "\t\t\t]",
        "",
        "\t\t\t# don't continue if max_tree_depth/2 is already reached (divide by 2 because we can branch to multiple directions)",
        "\t\t\tif unvisited_neighbors_deltas and (",
        "\t\t\t\tcurrent_tree_depth <= max_tree_depth / 2",
        "\t\t\t):",
        "\t\t\t\t# if we want a maze without forks, simply don't add the current coord back to the stack",
        "\t\t\t\tif do_forks and (len(unvisited_neighbors_deltas) > 1):",
        "\t\t\t\t\tstack.append(current_coord)",
        "",
        "\t\t\t\t# choose one of the unvisited neighbors",
        "\t\t\t\tchosen_neighbor, delta = random.choice(unvisited_neighbors_deltas)",
        "",
        "\t\t\t\t# add connection",
        "\t\t\t\tdim: int = int(np.argmax(np.abs(delta)))",
        "\t\t\t\t# if positive, down/right from current coord",
        "\t\t\t\t# if negative, up/left from current coord (down/right from neighbor)",
        "\t\t\t\tclist_node: Coord = (",
        "\t\t\t\t\tcurrent_coord if (delta.sum() > 0) else chosen_neighbor",
        "\t\t\t\t)",
        "\t\t\t\tconnection_list[dim, clist_node[0], clist_node[1]] = True",
        "",
        "\t\t\t\t# add to visited cells and stack",
        "\t\t\t\tvisited_cells.add(tuple(chosen_neighbor))",
        "\t\t\t\tstack.append(chosen_neighbor)",
        "",
        "\t\t\t\t# Update current tree depth",
        "\t\t\t\tcurrent_tree_depth += 1",
        "\t\t\telse:",
        "\t\t\t\tcurrent_tree_depth -= 1",
        "",
        "\t\treturn LatticeMaze(",
        "\t\t\tconnection_list=connection_list,",
        "\t\t\tgeneration_meta=dict(",
        "\t\t\t\tfunc_name=\"gen_dfs\",",
        "\t\t\t\tgrid_shape=grid_shape_,",
        "\t\t\t\tstart_coord=start_coord,",
        "\t\t\t\tn_accessible_cells=int(n_accessible_cells),",
        "\t\t\t\tmax_tree_depth=int(max_tree_depth),",
        "\t\t\t\t# oh my god this took so long to track down. its almost 5am and I've spent like 2 hours on this bug",
        "\t\t\t\t# it was checking that len(visited_cells) == n_accessible_cells, but this means that the maze is",
        "\t\t\t\t# treated as fully connected even when it is most certainly not, causing solving the maze to break",
        "\t\t\t\tfully_connected=bool(len(visited_cells) == n_total_cells),",
        "\t\t\t\tvisited_cells={tuple(int(x) for x in coord) for coord in visited_cells},",
        "\t\t\t),",
        "\t\t)"
      ]
    },
    "maze_ctor_kwargs": {
      "start_coord": [
        0,
        0
      ]
    },
    "endpoint_kwargs": {
      "except_on_no_valid_endpoint": false
    },
    "_fname_loaded": null,
    "fname": "start_corner-g10-n10-a_dfs-h18070",
    "versions": {
      "config": "1.0",
      "maze_dataset": "1.3.2"
    }
  },
  "fname": "start_corner-g10-n10-a_dfs-h18070"
}